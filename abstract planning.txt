Write Abstract for Proposal
- Problem Significance
- Skip Literature Review, Summarize Comparison Table (use latest version)
- Show Object Representations
	- Objects/Locations/Characters
		- Character Biases
	- Timestep VS Absolute Step
	- Rules, Tasks
	- Changes
		- RelChanges
		- TagChanges
		- Conditional Changes
		- TaskChange
		- TaskAdvance
		- TaskCancel
- Show current algorithm instead of the proposed one
- Metrics and Evaluation
- Progress -> Program is complete and is in the testing phase

Abstract
Our goal is to create a storytelling tool to aid video game story writers by visualizing potential interactions in a storyboard format. We intend to base our work on Artificial Folklore for Simulated Religions [1] and ReGEN [2]. This tool will allow the simulation of characters interacting with each other and the world, and output the actions as a graph, which human writers can use to base their stories off of.

The features we intend to include in our work include:
- Multiple Main Characters with Parallel Stories: At least two main, non-trivial characters can have storylines that are independent from each other.
- Constraint Controls: Users can create rules and conditions for the game world, and characters must act according to those rules.
- World State: The information about locations and relationships between characters are kept.
- Character Affinities: Characters can act according to their pesonalities, biases, and are more likely to do actions that fit with their personality.
- Focus on Certain Characters: Since not all characters are main characters, the system should be able to focus on main characters such as the protagonist, character who are close to the protagonist, main antagonist, et cetera.

Object Representation Within the Game World
We would like to represent different things in the Game World, therefore, each of the items we need to make the Story Graph will be represented in the following way:

Objects: Objects are things in the game world. They will have names, and tags describing what they are and their properties. Tags are descriptors with a value to clarify the desciptor. They are kept as a dict key/value pair. For example, an expensive sword imbued with the element of fire may have the following tags: {"Type":"Weapon", "DamageType":"Slash", "Element":"Fire", "Value":"Expensive"}

Location: Locations are a type of object that represent places. They can hold objects and other characters. Similarly to objects, the state of the location will be kept in the WorldState.

Characters: Characters are a type object that represent characters and actors in the game world. In addition to names and tags, they will also have biases leading them towards preferred actions and a starting timestep which dictates when this character first appears chronologically. Character relationships and inventory will be noted in the World State, which can change according to actions.

Edges: Edges denote relationships between two different objects. Each edge has a name and optionally a value to describe the relationship further. For example, an edge named "loves" with the value of "personality" pointing from Alice to Bob means that Alice loves Bob because of his personality.

Biases: Character biases are simplified into two axes: the LawBias axis and a MoralBias axis, limited to a value between -100 and 100. This is based on Dungeons and Dragons [3], where character alignments are Lawful to Chaotic in one axis and Good to Evil in another.

Time Measurement: The story graph uses two values to determine time in the story graph. They are as follow:
- Absolute Step: The smallest unit of time, each Absolute Step covers for one action performed by a character. The first story node in a character's storyline has the Absolute Step value of 0, the next one is 1, and so on.
- Timestep: A larger unit of time that specifies clearly that an group of actions and events take place before another group. One timestep may have multiple Absolute Steps within to denote that those Absolute Steps are taking place in roughly the same time period. In order to ensure a consistent order of events, replacement rules will avoid replacing events that span across more than 1 timestep. Timestep starts counting from 0, similarly to Absolute Step.
- Example: Alice's storyline has two Timesteps, Timestep 0 contains Absolute Steps 0, 1, 2, 3. Timestep 1 contains Absolute Steps 4, 5, 6. Even if Absolute Steps 3 and 4 contains a pattern that fits with a certain replacement rule, that replacement rule can't be applied.

Story Nodes: The nodes consisting of actions performed by characters. Each Story Node consists of properties such as the following:
- Name: What the Story Node is called.
- Bias Weight: The bias score inherent to this node. The higher this value is, the more likely this node will be favored by the choosing algorithm.
- Tags: Tags describing the Story Node.
- Charcount and Target Count: The number of characters that fit within this node. Sometimes, a node can be free-sized or a range can be given.
- Actor and Target: The list of actors and targets performing this action.
- Location: The Location object where this action is taking place.
- Previous Nodes: A dict linking to the node in the previous Absolute Step. The key is the character's name, and the value is the node that they performed in the previous Absolute Step.
- Next Nodes: A dict linking to the node in the next Absolute Step. The key is the character's name, and the value is the node that they will perform in the next Absolute Step.
- Timestep: The Timestep that this node belongs in.
- Absolute Step: The Absolute Step that this node is.
- Effects on next WS: The Change Objects representing the changes that will happen once this Story Node has been performed.

TODO (Important): Discuss with Professor what to do with these things. Why are some tests baked into the Story Node and some tests have their own object. Shouldn't we make things consistent? Why did I notice this just now?

ANSWER: We should. We should worry about this after the Mini Paper, though.

- Required Tags List: Tags that must exist on a Character object in order for them to be able to be an Actor in this node.
- Unwanted Tags List: Tags that must NOT exist on a Character object in order for them to be able to be an Actor in this node.
- Bias Range: The bias range that a Character must fall in in order for them to be able to be an Actor in this node.
- Required Tags List Target: Tags that must exist on a Character object in order for them to be able to be an Target in this node.
- Unwanted Tags List Target: Tags that must NOT exist on a Character object in order for them to be able to be an Target in this node.
- Bias Range Target: The bias range that a Character must fall in in order for them to be able to be an Target in this node.
- Suggested Included Tags List: Tags that must exist on a Character object in order for them to be able to be an Actor in this node.
- Suggested Excluded Tags List: Tags that must NOT exist on a Character object in order for them to be able to be an Actor in this node.
- Suggested Bias Range: The bias range that a Character must fall in in order for them to be able to be an Actor in this node.
- Suggested Included Tags List Target: Tags that must exist on a Character object in order for them to be able to be an Target in this node.
- Suggested Excluded Tags List Target: Tags that must NOT exist on a Character object in order for them to be able to be an Target in this node.
- Suggested Bias Range Target: The bias range that a Character must fall in in order for them to be able to be an Target in this node.

- Condition Tests: The list of ConditionTests that this node must satisfy in order to be used. More information in the Condition Test section.

Condition Test: This class of objects represents the conditional test that must be satisfied in order for a Story Node to be valid within a Story Graph. The test is passed when the condition specified in the test is met, unless it is an Inverse Test, in which the test is passed when the condition is not met. There are three types of Condition Tests, they are as follow:
- HasEdgeTest: This tests whether or not a certain relationship between two objects exist. It can test for value as well as edge name, can use Soft Equal (ignores value), and can test for two-way relationships.
- HeldItemTagTest: This tests whether or not an object is holding another object with a certain tag.
- SameLocationTest: This tests whether or not all the characters listed in this test all share a location.

World State: The state of the world at a specific point in time. It contains the information regarding relationships between various game world objects, as well as the status of each object.

Story Graph: The story graph containing the actions of characters. Each character in the story will have their own storyline here. The Story Graph starts from the shared 0th World State, which is then followed by each characters' 0th Story Node. This is then followed by the 1st World State, which is the world state that results from applying the changes that happened to the 0th World State by performing all nodes that were performed in the 0th Absolute Step. This pattern is continued until the last Story Node has been performed.

In order to save on space, only the first World State and the Latest World State are recorded. Anything in between can be spontaneously generated by applying changes up to that point, and discarded when it is no longer needed.

Change Objects: In order to denote changes occuring to the characters in the story and the world state as the story plays out, we have created Change Objects to put into Story Nodes to label the changes that would occur within the game world objects and the world state when that action is taken. The Change Objects are as follow:
- Relationship Changes: This change object denotes the change in relationships within the World State. When this change is applied, an Edge connecting from one object to another can be added or removed from the World State. A value may be assigned to an Edge if it's an addition. It is also possible to connect or disconnect two-way relationships.
- Tag Changes: This change object denotes the change in tags within an object in the World State, either by adding a new tag or removing an existing tag. Since tags are kept as a key-value pair in a dict, adding a tag with a key that already exists will overwrite it.
- Conditional Changes: This change object applies to multiple characters at once, and denotes changes that occur to a group of characters at once, if the characters pass the test given in the change. Conditional Changes come with a list of Condition Test that will be tested on a list of Character Objects, also provided by the Conditional Change. If a character passes all the tests, all the changes listed in the Conditional Change will be applied to them.
- Task Changes: This change denotes a character giving a Task Stack to another character. More on Tasks will be expanded in the Character Task and Task Stack section.
- Task Advance: This change denotes a Task Stack being advanced to the next Task.
- Task Cancel: This change denotes a Task Stack being cancelled. Usually, this is called in order to remove tasks that are no longer possible to complete due to changes in the World State.

Generic Object Nodes: There are certain times that we would like to apply tests or changes to characters listed in certain slots in the story node. For this purpose, we use Generic Object Nodes in place of actual Character Objects so that they can be replaced by actual Character Objects that fit the Generic Object Node's quality. The Generic Object Node Types are:
- GENERIC_ACTOR: The placeholder will be replaced by the first actor in the Story Node that the change/test is attached to.
- GENERIC_LOCATION: The placeholder will be replaced by the location in the Story Node that the change/test is attached to.
- GENERIC_TARGET: The placeholder will be replaced by all targets in the Story Node that the change/test is attached to.
- ALL_ACTORS: The placeholder will be replaced by the entire list of actors in the Story Node that the change/test is attached to.
- CONDITION_TESTOBJECT_PLACEHOLDER: For use in Conditional Changes. The placeholder will be replaced by the characters being tests/having changes applied if the condition tests are passed.
- TASK_GIVER: For use in CharacterTask and TaskStack. The placeholder will be replaced by the character who assigned the task.
- TASK_OWNER: For use in CharacterTask and TaskStack. The placeholder will be replaced by the character who owns the task, i.e., the character responsible for performing the task.

Task Stack: In order to simulate quests in a role playing game, characters will be able to assign task stacks to each other. Each Task Stack contains the list of tasks that must be done. Each Task Stack comes with a list of tests that has to be passed in order for the task to be valid. For each Task Stack, there will be a dict that act as a placeholder dict as well, for characters who may appear in the task. These placeholders do not fall into Generic Object Nodes and are string placeholders, except for the Task Giver and the Task Owner, who will appear in every task.
For example, the Task Stack describes a questline where the Task Giver requests the Task Owner to kill a character that the Task Giver hates. We use the string "kill_target" to use as placeholder for the target in this task, and use conditionals to test for whether or not the Task Giver hates "kill_target".

A task stack is usually advanced as the individual tasks within the stack are completed, but they can also be advanced without completing steps if the condiitons to complete a task is already set. For example, Alice gets a task from Bob to kill Charlie, and once Alice arrives at the location to kill Charlie, Charlie is already dead. Alice would then be able to move onto the next step of the task where she claims a reward from Bob for Charlie's death.

Tasks can also br cancelled if the conditions to complete the task is no lnger there. For example, Bob wants Alice to deliver a letter from himself to Daniel. However, this task cannot be completed if Daniel is dead, and it should be cancelled.

Character Task: A subunit of the Task Stack. Each Character Task has a list of StoryNodes that will be performed once the task is performed, and the location where this task could be performed. Each Character Task comes with a list of tests that has to be passed in order for the task to be valid.

Algorithm:
The algorithm used to generate a Story Graph is as follow:
[Image description: Flowchart.]

Example Story Graph:
A story graph generated by this algorithm might appear as follow:
[Image description: Story Graph, alternating between a shared world state containing information of the world and story nodes performed by characters.]

Current Progress:
Currently, the program is mostly complete, and we are currently in the testing phase to ensure all parts are working correctly and can generate story graphs as intended. After this step is complete, we will begin setting up for testing with metrics such as, as well as testing with human users to test user friendliness and the effectiveness in generating story graphs.

FOR REAL PAPER
    \item Relationship Changes: This change object denotes the change in relationships within the World State. When this change is applied, an Edge connecting from one object to another can be added or removed from the World State. A value may be assigned to an Edge if it's an addition. It is also possible to connect or disconnect two-way relationships.
    \item Tag Changes: This change object denotes the change in tags within an object in the World State, either by adding a new tag or removing an existing tag. Since tags are kept as a key-value pair in a dict, adding a tag with a key that already exists will overwrite it.
    \item Conditional Changes: This change object applies to multiple characters at once, and denotes changes that occur to a group of characters at once, if the characters pass the test given in the change. Conditional Changes come with a list of Condition Test that will be tested on a list of Character Objects, also provided by the Conditional Change. If a character passes all the tests, all the changes listed in the Conditional Change will be applied to them.
    \item Task Changes: This change denotes a character giving a Task Stack to another character. More on Tasks will be expanded in the Character Task and Task Stack section.
    \item Task Advance: This change denotes a Task Stack being advanced to the next Task.
    \item Task Cancel: This change denotes a Task Stack being cancelled. Usually, this is called in order to remove tasks that are no longer possible to complete due to changes in the World State.
	
	\item \texttt{GENERIC\_ACTOR}: The placeholder will be replaced by the first actor in the Story Node that the change/test is attached to.
    \item \texttt{GENERIC\_LOCATION}: The placeholder will be replaced by the location in the Story Node that the change/test is attached to.
    \item \texttt{GENERIC\_TARGET}: The placeholder will be replaced by all targets in the Story Node that the change/test is attached to.
    \item \texttt{ALL\_ACTORS}: The placeholder will be replaced by the entire list of actors in the Story Node that the change/test is attached to.
    \item \texttt{CONDITION\_TESTOBJECT\_PLACEHOLDER}: For use in Conditional Changes. The placeholder will be replaced by the characters being tests/having changes applied if the condition tests are passed.
    \item \texttt{TASK\_GIVER}: For use in CharacterTask and TaskStack. The placeholder will be replaced by the character who assigned the task.
    \item \texttt{TASK\_OWNER}: For use in CharacterTask and TaskStack. The placeholder will be replaced by the character who owns the task, i.e., the character responsible for performing the task.
	
	\section*{Acknowledgment}

Ram S. would like to thank Asst. Prof. Vishnu Kotrajaras for his guidance and advice in maki. Ram S. also would like to thank his family, his friends (offline and online), his colleagues in Computer Department's Game Lab, and his fellow computer game enthusiasts in Chulalongkorn University's Game Research and Development Club for the moral and mental support they gave, be it directly or indirectly.

In order to ensure a consistent order of events, replacement rules will avoid replacing events that span across more than 1 Timestep. Timestep starts counting from 0, similarly to Absolute Step.

Affinity-Based Multi-Character Storyboard Generation Using Rewrite Rules