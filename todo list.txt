11 Aug 2022 (ALL BACKLOGS COMPLETE)
    - Handle Actors and Targets (DONE)
        - Add a new property in StoryNode that specifies target, and allow the target to be any type of object node. (Done)
        - Add a new property in JointNode that specifies target or actor.
            - This will have to be done both for Normal Rules and Joint Rules
              - For Normal Rules, there is a List of Targets
              - For Joint Rules, there is a List of Targets
    - Handle only one character splitting (DONE)
    - Solution is to instead of splitting into individuals, we split into groups instead (DONE)
        - For example, a node containing Alice, Bob, Charlie, and Dave fits the criteria for a split
        - The next node should allow them to split into two groups, Alice Bob and Chalie into left node with no target, dave becomes the main actor of right node
    - test the Joint Node Graph codes to make sure that they work (DONE)
    - Look at REGEN Code (Done)
    - Init Rules:
        - Assassinate
        - Break Ally
        - Fight
        - Forge Ally
        - Give Blackmail Letter
        - Give Gift
        - Murder
        - Murder Blackmailer
        - Rebel
        - Spy
        - Steal
    - Replacement Rules:
        - Ambush
        - Ambush by Hater
        - Caught
        - Encounter
        - More Fight
        - Spare
        - Stealth Kill
        - Stolen Gift
18 Aug 2022 (ALL BACKLOGS COMPLETE)
    - Flexible rules that allows nodes with any number of actors, allowing them to be used in multiple instances (DONE, UNTESTED)
        - For example:
            - If there is more than 1 person doing X, then they are eligible to do Y together with no targets in the next node
    - Get rid of Dummies OR change equality testing (DONE, Dummies gotten rid of in Joint!)
    - How do I even handle targets from the perspective of the Rewrite Rules???? (DONE, TESTED)
        - Since a large portion will be replaced, do I need to list out the targets in all of those instances?
        - What do I need to do with the targets of these ones?
        - (PAPER PLOTTING REQUIRED)
25 Aug 2022 (ALL BACKLOGS COMPLETE)
    - Handle Targets for Joint Rule (DONE)
    - Test Multi-Group Splitting Rule (DONE)
    - Check Proposal to Compare (DONE)
        - Quality Metrics needs to be done
        - I think that almost everything in regards of the graph has been done except:
            - The untested and the unadded
            - The program that ties up all the components together
                - This includes a function that automates relationship change with targets
            - Graph Visualization
        - Generic Constraints
    - Read and Summarize new Kybartas Paper (DONE)
        - Uses the same story metrics as REGEN
08 Sep 2022
    - Map Representation in World State (DONE)
        - Function in World State, that given a LocationNode, returns all adjacent locations
    - StoryGenerationFunction's rule application will make a Location List this way:
        - Assume the location doesn't change
        - However, if there is an action node that calls for a location change, refer to the map and choose one random location to change to
        - After that, all the actions will be performed in that location unless there is another change
    - Location Adjecnecy Function in World State (DONE)
15 Sep 2022
    - Change the future World States according to Present (Done)
    - Memory issues from copying WorldStates, how much is too much
    - Record only changes to WorldState, keep latest version (DONE)
        - Pending: Rewind back in case of errors
        - Keep 2 world states: Initial Worldstate and Current Worldstate
            - In the case that there is a change to the worldstate, take the initial worldstate and apply all the changes in each step, then make that the new current worldstate
    - Function that takes Tag and Value as input, and then outputs the proper relationship change (where actor/target can be added later) (Done)
    - ApplyRule, but with past timesteps
        - 
    - Check if Character is in the same location
        - Take the init step, advance it until it hits the place we want to check, and then check relationship
25 Sep 2022
    - Undo state changes (DONE)
        - Run from the initial state, input number and run through?
        - Run from final state, input number and reverse?
    - Effect on next Timestep must be developed in order to define how the stories will change (Partially done, but still unsure)
        - Either this, or parameters are needed
            - Figure out what parameters are needed
            - Define how each actions/events will change states and tags
    - Rule Change in the story cannot force the State Changes yet
        - Oh, they are about to. We just need a little bit of setup.
    - Rewrite Rule that applies Story Node Changes then applies World State Changes (Planned, now we intend to interleave to make things clearer)
2 Oct 2022
    - Since RewriteRule uses Tags and Tags are supposed to depend on the current world state, we need to think of what we're supposed to do here
        - Only take into account the first step of the rewrite rule???
        - Remake it so that instead of attaching tag requirements to the change rules, attach requirements to the story nodes instead and check appropriateness of each node as the world state advances?
    - Interestingly, there is no reason that rewrite rule has to take StoryGraph as an input
        - We could use lists of story nodes as condition/replacement for stories
        - We could use lists of world states as condition/replacement for world states (and run a check)
            - Tags work with this method, however, World States requires concrete Characters and Objects, so we'll have to make customized rules for more specific nodes.
    - Still need to check if Character is in the Same Location
        - New EdgeReq type object?
        - ShareLocReq?
            - Contains a list of characters
            - Check the location of the first character, then check if the other characters are in the same location?
    - Need to remake WorldState to interleave with StoryNodes? (DONE)
    - We also need to have the RelChange pull the character from the WorldState instead of the initial character setting (Done)
        - This is required in order to make sure the characters are properly affected by changes when they take actions
        - Instead of calling objects directly, RelChange should contain the name and call the tag's name from the WorldState
        - We can do this, we have node_dict[(node name)]. We'll use it to call the node from the proper WorldState after all the required change are applied.
    - Paired items that are required in order to interact with other items
        - Need a specific key to interact with a door
        - Skeleton Keys exist, and might be able to open all doors
        - Like prof. said, this could work with pairing objects. Example:
            - Red Key {Type: Object, Unlocks: Red}
            - Red Door {Type: Object, State: Locked, UnlockWith: Red}
            - Skeleton Key {Type: Object, Unlocks: [Red, Green, Blue]} (We can exclude tags that a Skeleton Key don't unlock (For example: digital locks with no keyholes))
        - Tag Requirement for Items?
    - Did a bit of housekeeping and reduced some duplicate code into functions (Entire work will never be done but a lot of it was done. Thanks Ram!)
    - Break up with Magic Variables/Strings and use ENUM-like configurations instead. This includes: (DONE)
        - "add", "remove"
        - Markers for relative nodes
        - Joint Types
9 Oct 2022
    - How important is StoryNode.next_node, exactly...?
        - Since we could figure out next node/previous node information from the StoryGraph itself, it might not be that needed...
        - We'll keep it for now, but if it turns out there's no need to put it there we're removing it to streamline our work process.
13 Oct 2022
    - We need to discuss on how to handle adding step insertion
        # The Problem:
        # How to handle insertion?
        # In the examples, Char A and Char B have steps 0 to 4. A-B is inserted between 3 and 4 for Char A.
        # 1. Don't insert anything, non-inserted storyline stays where they are:
        # A: 0-1-2-3-A-B-4
        # B: 0-1-2-3-4
        # Pros: No need to alter storyline more than needed.
        # Cons: Might cause time to be a bit weird and joint nodes might end up in different steps.
        #
        # 2. Insert a few blank steps in the unaltered character's storyline.
        # A: 0-1-2-3-A-B-4
        # B: 0-1-2-3-X-X-4
        # Pros: Joint nodes will always be in the same timestep.
        # Cons: Might need to rework the "End Condition" to exclude wait nodes.
    - it's decided, we'll take case 1 (as long as it's in the same timestep, it should be fine, absolute step shouldn't matter)
    - We can use character to point back at Location? (DONE)
    - Same Location, use location from Story Node to check? We can do Follow Graph (DONE)
        - Same Location can now be checked! Hooray!
    - Moved Enums to Utility (DONE)
20 Oct 2022
    - Work on the ConditionTest objects, so that changes can be dictated using them (DONE)
    - Consider if other ConditionTest objects are needed
        - We will only go with the basic 4 tests for now and make more as needed.
03 Nov 2022
    - Created a new function called Fill Locations On Self, which allows Location Data to come from the WorldState instead of the add node input itself (DONE)
    - Finished the function called Check Continuation Validity that checks if a given continuation is valid. (Done, Partially Tested)
    - Make Inverese tests (DONE)
    - Revise the Apply Rule function so it only adds rather than remove then add
        - This also means we must also redo the apply replacement rule function?
10 Nov 2022 (Happy Birthday! You're 3 days late)
    - Redo the Replacement Rules to maybe include a slot for targets so that we can pull information from there into the add node function
        - Replacement rules no longer need dummy char, because we will now only use a list of nodes
        - target list will also be able to be included
        - Put all the targets in the rewrite rules, yeah!
    - Need to redo quite a few functions!
        - is_subgraph (DONE)
        - rewrite rule function, so instead of removing nodes it only insert new nodes
            - Reasons to keep old function: Replacement could work for "Non-Terminal Symbols"
                - For example, Bob goes Outside -> (Heroic Deed) -> Bob Gets Awarded
                - Heroic Deed is intended to be a non-terminal symbol to be replaced that will be replaced with a storyline that fits the criteria of a heroic deed.
            - Proposal: Figure out a way to let the system know when to do replacement and when to do only insertion (DONE)
                - Special property within RewriteRule? (We could go with this, it's just one boolean) (WE DID THIS ITS DONE)
                - If the beginning is the same, don't replace?
17 Nov 2022
    - Current method only allows story nodes with unique names.
    - We probably should rename story nodes to make them less confusing.
        - Might need to ensure Story Node VS Character Node VS Location Node VS Object Node don't sound too confusing on Paper
        - Maybe go back to using StoryPart?
    - New Rewrite Rule is now done and has to be Tested
    - Check if the Joint Rule still works with the new WS format
        - Whoops, when I checked on friday it didn't. Good thing I fixed it on Monday!
        - Still needs testing, though.
    - Hey, uh, so remember the split joint thing we implemented? If we want to keep it, we probably need to figure out a way to include that information in the Rewrite Rules?
        - How do we know how to split? We put in a rule, and we give the split list some sort of distribution?
        - Distribution could be based on randomization or character bias ranking?
        - Make a list of all possible permutations and randomly choose one from the valid list?
        - Probably should consult professor about this
        - Random first, then check if this combination is good
    - Plot out Rules, Init Test WS, Characters, Objects, and decide the kind of story we want to generate (important)
24 Nov 2022
    - Change the Tag check requirements (Done and Tested!)
        - If the value is blank, then it can be anything
        - We extended this and added the values to the edges too.
    - Splitting Joint should just randomly assign characters and then go with the first combination that works (Done, Tested)
    - Since we rewrote a bunch of new Edge functions, we should test the following: (COMPLETE)
        - StoryNode: Check if Item has Tag (TESTED)
        - WorldState: Disconnect (TESTED)
        - Edge: Edge Equality (both __eq__ and soft_equal) (TESTED)
        - ConditionTest: HasEdge must be tested (Double Has Edge gets a free pass because it's based off of HasEdge) (TESTED)
    - Plot the World State and Initial Graph State, based on ReGEN
08 Nov 2022
    - Well, we did it, we're going to need more Replacement Rules
        - Take from Quest Generator
        - Finish implanting parts from ReGEN that we haven't added from the other sheet yet
    - Try to plot some representations in our code
        - Since we foresee that we will need a way to input the data, we will need to start working on the thing that will let us read json files/strings and translate them to proper objects
        - We need to figure out which JSON things we need and don't need as well
            - JSON Story Objects
                - JSON Locations
                - JSON Characters
            - JSON Story Graphs
            - JSON Story Nodes
            - JSON Replacement Rules
            - JSON RelChanges
            - JSON Edges
            - JSON Condition Tests
            - JSON World States
        - If we're doing JSON things we need to figure out how we handle connecting to other things
            - For example, defining an Edge requires referencing nodes. We need to handle that
            - Use the character/object name as IDs?
            - Make a new ID property?
    - Go read Quest Generator again to see where the story parts came from
        - Possibly Witcher?
        - Fallout? (Main Quest)
        - Skyrim (Main Quest)
        - I checked out these games and all they gave me are highly branched out questlines that feel like they'd be out of my scope to replicate
        - Also, I'm pretty sure the story parts used here are completely original, there doesn't seem to be any rules here...
15 Nov 2022
    - Update the JSON things to accept lists (Partially Done, need to do the CondTest list as well as Change List)
        - List of Connections (DONE)
        - List of Changes
        - List of Condition Tests
    - Need to test the JSON Functions that we wrote to see if it works (Done)
    - Determine all the JSON functions we need to write
    - Show the prof examples of nodes and objects from ReGEN in JSON Form
22 Nov 2022
    - There is no need to verify input. We can assume that all inputs are correct, given that the tools we use to create the JSON Files are always accurate.
        - However, we still need to verify inputs for things that we pull from World States, because we can't always assume that the requests will be reasonable.
        - Thanks to kwargs, this work is rendered trivial. Thank you Ami! You're cool
    - Continue working on Condition Test Reading and Story Node Reading
        - Condition Test List has been Tested, need to test Story Node Reading
    - Absolutely, positively, create examples from ReGEN
        - This, too, will be done soon.
05 Jan 2023
    - Write a document of components
        - Done
    - Create a JSON List of Story Nodes
    - Create a JSON List of Replacement Rules
    - Create the Algorithm that generates story from the available information
        - This is the toughest part.
12 Jan 2023
    - What was I doing?! I haven't even tested the Rewrite Rules or the Joint Rules??? (Testing Done for Rewrite Rules, Joint Rule Untested)
    - Also, we know who the characters in the joint rule are, we just don't know who will become a target? How to fix that?
    - Oh, yeah, maaaaybe just maybe the thing that generates random grouping can also be used to pick who the target should be, given the number of appropriate target? (Done, Untested)
        - Use this to pick among the number of valid characters. We gotta take care of this before we can take care of the generation.
    - I edited the thing that does the thing and now the Character Grouping Picker is now reliable. (Bad Combination Untested)
19 Jan 2023
    - Should we allow tuples to be used as character count and target count?
        - Professor suggests that would make things more flexible, therefore he recommends that this should be done.
        - Tuple ranges are done! We just need to do testing.
    - Now that we have written a lot more stuff, it would be smart to redo the program flowchart so that it contains the new functions we wrote, so that writing the main program is easier.
        - New Flowchart should be rewritten, but keep the old flowchart to explain how each new addition solves our problems specifically.
        - New Flowchart has already been rewritten
    - To Add: When given actor count and target count, do the math and convert it into range. (DONE)
        - For example:
            - (1, 5) and (1, 6) would add up to (2, 11)
            - (2, 4) and 3 would add up to (5, 7)
            - -1 and -1 would add up to -1
            - (1, 3) and -1 would add up to -1
            - 2 and -1 would add up to -1
26 Jan 2023
    - We now have the flowchart. Therefore, we can make the program, or at least, make it up to as much as we are confident with.
    - Something to deal with the Bias
        - In addition to Required and Unwanted Tags, add:
            - Suggested Tags: This is for score calculation
            - Function to calculate score for one node (DONE)
            - Function to calculate score from adding a list of nodes to a character's storyline (this advances the plot and thus suitability needs to be checked from) (DONE)

2 Feb 20223
    - Consider what we have to do with Joining Joint Node (DONE)
    - Still need to do some tests. (Most of these are in TODO, remove these TODO as you are done with them.)
    - Clean up the TODOs in the code comment, and from now on only use it for uncompleted tasks because WOW we have a lot of TODOs we have already taken care of. (DONE)
    - get_joint_node_steps_from_character_storyline completed, it will help look fofr Joint Nodes in the storyline. (Done, Untested)
9 Feb 2023
    - Multiple node bias score are MAX by default, can set to MEAN if desired
        - Professor suggested using only the character in the state at the start of the replacement rule for simplicity
    - Bias Score of the Splitting Joint can be calculated from averaging all possibilities.
    - Joining Joint Rule requires that there should be at least one of each node in the base 
        - For example, if applying Rule WXYZ requires has the base pattern with story nodes [W, X, Y, Z], then we know that we require at least 4 characters, and that all four story nodes must appear somewhere in the base pattern.
16 Feb 2023
    - Testing for Calculate Score completed
    - Wrote Calculate Score from Rule
    - Will need to do testing for Calculate Score for Rules
23 Feb 2023
    - THE TAGS! Of course, why did I not think about the tags!
    - Suggested include tags will only allow one key per value. I should have used tuple instead.
        - We do not need to handle these for objects and characters because most of the tags do not overlap (Job, Wealth, Living, Wanted, etc...)
        - We do however need to handle these for stuff like ConditionTests and StoryNode requied/unwanted tags for all unwanteds and all suggest slots (actor unwanted, target unwanted, suggest/target suggest)
            - Actor Wanted and Target Wanted: Not needed because if two tags with the same keys are wanted, it can never be fulfilled
            - Bias Ranges: Not needed because most actions don't have bonus for extreme on either sides (excluding neutral)
    - Merge Count from the Joint Rules is useless and redundant, get rid of it (We can already know how many characters we want from the continuing splits/joints information, so merge count can go bye-bye. Luckily, we don't seem to be using merge_count elsewhere.)
    - Continue the testing and add the function to the main function finally.
2 Mar 3
    - We should create a function when, given a story node split list and a bunch of character names, returns True and a character grouping that splits the characters properly according to the following rules. If no good grouping is found, then return False, then an empty list:
        - Make a list of all possible groupings from the list of node. Each tuple in the list represents a node grouping.
            - For example, if it's a non-joint node without targets, then we would expect a tuple of size one.
            - If it's a joint node, the tuple is size two. Index 0 are actors. Index 1 are targets.
            - If the number of actors and the number of total slots from the split list are inequal, return False, and an empty list.
        - Assign characters to the nodes.
        - Test for story graph and world state validity.
            - If the test fails: remove this grouping from the list of all groupings.
            - If the test passes: return True, and this grouping.
        - Finally, check if there are any groupings left in the possible list.
            - If there are, loop to beginning.
            - If there are not, return False, and an empty list.
    - Since world state is involved, this function should be written in WorldState. Then, it can be called from the created state by SG2WS.
        - We already did this partially, it's in SG2WS.
9 Mar 2023
    - Do not need to verify rules before adding them to list, we should verify them in the loop instead, so we know the other actors that we intend to use joint rule with.
    - The initial rule list is the entire possibility of rules, sorted by its score.
    - When we pick Top N, do not destroy the rest of the list. We should preserve it for the case where the current rule is invalid, then we push the one that's just out of range into the choose range.
    - Wait would happen when none of the rules in the list are valid.
    - New setting: Extra Attempts
        - If set as -1, the algorithm will continue to push new rules into Top N until there are no more, or until a good one is found.
        - If set as any other integer, the algorithm will stop pushing new rules into Top N after X attempts, where X is the integer.
        - When there are no more Top N, then the character has no valid actions and therefore has to do the wait action.
    - Need to fix accessibility issues for future coders: Write description for each function in triple quotes.

16 Mar 2023
    - Metrics during generation to calculate bonus score?
    - Use REGEN's setting to generate story
    - Complete Joint Rule 
23 Mar 2023
    - Yay! We completed the main function!
    - We need to do some testing, though, so we should take some things from ReGEN and as faithfully as possible, translate it to our system and run some testings to see if our story are similar to ReGEN
        - Branching stories should be translated to 
    - Compare between our work and ReGEN, what do we have that they don't?
        - Multiple characters: ReGEN has only one player character, we should test multiple characters
        - Afifinities: We should also test affinities later (ReGEN doesn't have lawbias or moral bias)
        - Timesteps: ReGEN doesn't have a strict concept of time, because it assumes the questline goes as quickly as the player's playing speed
    - How does time progress in our work, actually?
        - Time should stop when it's not observed by any characters?
        - Time should stop when it's not observed by a player or someone marked as a player?
        - Time should stop when it's not observed by a player AND not interacted with by a player?
        - Time should stop when it's not observed by a player, and it will move again when it's observed by the same player.
        - Frozen Quest? Freeze only important quests?
        - Events resolve before players can do them? Look into this after testing.
30 Mar 2023
    - The following things have been done since the last update:
        - StoryGenerator is finished, but testing hasn't started yet because we haven't recreated ReGEN's Worldstate yet
        - Generic objects added to JSON Reader
        - Tag Changes and Rel Changes added to JSON Reader
        - Added new characters to the REGEN JSON Objects (Player Characters to act with the NPCs)
6 Apr 2023
    - There are things I need to handle because those were in ReGEN:
        - Conditional Changes (If X likes Y, then X will hate Z, etc. ConditionalTagChange and ConditionalRelChange? We can probably use ConditionTest together with TagChanges)
        - Concept:
            - Condition: The condition that will be tested
            - Change: The RelChange that will be applied if the Condition passes the test
        - Concept 2:
            - List of Tested Objects
            - List of Tests: The test that will be checked for each object in the list. The placeholder object will be replaced with each object in the list. A tested object must pass all tests in this list to be elilgible for condition.
            - List of Conditions to Apply: The RelChanges and TagChanges that will be applied. Note that for each of the condition, the placeholder will be where each object that passes the test will be placed before it's applied.
        - Example of Concept 2:
            - List of Tested Objects: All NPCs from List of Notes
            - List of Tests: (Placeholder) is in (Generic Location) and (Placeholder) likes (Generic Target)
            - List of Conditions to Apply: (Placeholder) hates (Generic Actor)
13 Apr 2023
    - Let's forget about doing the JSON reader for now, that is NOT our main focus. We just want the WorldState of ReGEN's work in a tangible form, JSON readability is for user convenience, which can come after we've gotten all the details of the core work down
    - We should be able to make a bunch of objects in a file and then show that to professor
    - We already have all the objects and relationships, those were defined in JSON already
    - We just need to make up the story parts and the condition tests, which might take a bit to do
    - Making and testing ConditionalTest is necessary for the next step.

Simulacra Paper from Prof.
ChatGPT Memories
Module that summarizes changes of character in long term
Reflection
Emergence -> Can simulate events, no scripting required -> Can't really control story?
For NPCs in game? However Important NPCs might not always act rationally like ChatGPT does otherwise they may not follow the story or may be lost to players

20 Apr 2023
    - Two Way for RelChange
    - Soft Equal for RelChange
    - List of Current Quests?
        - Sort by Nearby Quests, Randomized
            - Therefore, some nearby quests will not be resolved
        - Sort by Quest Importance, Randomized
        - If cannot solve, increase difficulty level
        - Aren't characters usually motivated by one main goal in the story anyways?
        - Intended story doesn't have to be the forced order

    - For side quests, generate using part of world state and make sure it doesn't change the world much
    - Add intensity of relationships (love, hate, friendship, dislike)
        - For example, if A kills B and C hates both A and B, C will hate A slightly less

    - The Sims doesn't affect World State too much, and the stories are mostly daily lives
    - Maybe Generative Agents have been cherrypicked?
    - Simulacra Relevance
        - Our work: Multiple factors drive the story to guide storywriter
        - Their Work: Tell Agents what to do, but cannot control direction the story will go?
        - We are Not the Same
        - Quality might be similar in that characters play out their stories?
        - Ours: Already have a direction, there are only expected changes
        - Theirs: Emergence, we don't know the direction, we can predict where it will go, but there can be unexpected changes
        - The usage is also different
        - The world changes state in a different scale, Simulacra has very minor world state changes
    - Large World State Changes
        - Someone dies
        - A ghost town is revived

    - scale, use case, micro simulations may be wasteful'

27 Apr 2023
    - Facilitate the use of Tasks in SG2WS
    - Make a Task object
        - Task Object consists of the following properties:
        - Task Name
        - Task Actions: The StoryNode actions that a character with the task will performed
        - Task Location: The location that the character must be in to complete the task. Will be blank for non location specific tasks.
        - Task Conditions: The conditions that the task can be performed. (For example, sharing a location with someone, having an item, etc.)
            - Note: The character who has the task must also have appropriate tags and relationship requirements within the node 
    - Add a 
    - Add a function that check for tasks that can be done in the current location
    - Add a function that check if a task can be done
    - Add a function that does tasks in SG2WS
    -
    - OKAY So. Apparently the characters do not move in ReGEN, so they don't have this problem where players want to go talk to someone but they are not at the location. Hmmm how do we fix this
        - Only player characters will move, NPCs will stand still
        - The NPCs that can move are designed to be in specific apply_relationship_change
        - Traveling merchants might not be core to the core story that the players 
        
4 May 2023
    - Slight problem for counting the locations:
        - The counting of seen locations in the closest node function assumes that all the locations are connected in a web. What if there are disjointed locations?
        - This problem cannot be ignored, because sometimes games will give you quests that require going to locations that aren't locked yet. You can't do these quests until those locations are accessible at a later point in the game.
        - Good News! We are now able to count number of locations connected with a new function called count_reachable_locations_from_location in worldstate
    - Should be able to try ReGEN world state once more now. Good Luck!

11 May 2023 -> 12 May 2023
    - We must determine how tasks will work with our current system.
        - Tasks must be able to be added to characters, and their addition must be able to be recorded in the world state
        - Tasks must remember when one of its actions was performed and mark it in the world state
        - Tasks must be a viable option to undertake alongside other rewrite rules
        - If a task can no longer be completed due to the changed world state, then the change in the worldstate must be deemed invalid and not allowed
        - If a new task given to another conflicts with another task, then that task should not be given
            - Alternatively: Still give the task, but update the task and skip certain actions if the things has already been completed by another character or is no longer possible to do
        - What do we do with tasks after we reach the required length but the the task stack isn't completed yet
            - Calculate the length for each item in the task stack, tip weights towards not taking more tasks if it would take the story over the step requirement, while focusing on completing current tasks

        - A task can be expanded on if it exists and it hasn't been completed
        - For example, if a task was given at Absolute Step 5, it cannot be done before that step.
        - A task can be progressed if it already passed by that step where it was assigned, the character is in the correct location to perform the task, and the other conditions for applying story nodes apply appropriately.
            - For this reason, we added a counter to count what absolute step the quest was added.
            - Additionally, each separate task also requires a counter when it was performed, so subsequent tasks of the same stack cannot be performed in the wrong order.

20 May 2023
    - Characters can cancel tasks that are no longer possible / Already done for them
        - Characters should be rewarded even if the quests are already done for them
        - It depends on the context as well, the quest requester might have specifics that cannot be ignored.
    - Read ReGEN paper again to make more comparisions
    - Finish the task continuation functions in SG2WS