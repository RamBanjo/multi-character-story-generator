11 Aug 2022 (ALL BACKLOGS COMPLETE)
    - Handle Actors and Targets (DONE)
        - Add a new property in StoryNode that specifies target, and allow the target to be any type of object node. (Done)
        - Add a new property in JointNode that specifies target or actor.
            - This will have to be done both for Normal Rules and Joint Rules
              - For Normal Rules, there is a List of Targets
              - For Joint Rules, there is a List of Targets
    - Handle only one character splitting (DONE)
    - Solution is to instead of splitting into individuals, we split into groups instead (DONE)
        - For example, a node containing Alice, Bob, Charlie, and Dave fits the criteria for a split
        - The next node should allow them to split into two groups, Alice Bob and Chalie into left node with no target, dave becomes the main actor of right node
    - test the Joint Node Graph codes to make sure that they work (DONE)
    - Look at REGEN Code (Done)
    - Init Rules:
        - Assassinate
        - Break Ally
        - Fight
        - Forge Ally
        - Give Blackmail Letter
        - Give Gift
        - Murder
        - Murder Blackmailer
        - Rebel
        - Spy
        - Steal
    - Replacement Rules:
        - Ambush
        - Ambush by Hater
        - Caught
        - Encounter
        - More Fight
        - Spare
        - Stealth Kill
        - Stolen Gift
18 Aug 2022 (ALL BACKLOGS COMPLETE)
    - Flexible rules that allows nodes with any number of actors, allowing them to be used in multiple instances (DONE, UNTESTED)
        - For example:
            - If there is more than 1 person doing X, then they are eligible to do Y together with no targets in the next node
    - Get rid of Dummies OR change equality testing (DONE, Dummies gotten rid of in Joint!)
    - How do I even handle targets from the perspective of the Rewrite Rules???? (DONE, TESTED)
        - Since a large portion will be replaced, do I need to list out the targets in all of those instances?
        - What do I need to do with the targets of these ones?
        - (TODO: PAPER PLOTTING REQUIRED)
25 Aug 2022 (ALL BACKLOGS COMPLETE)
    - Handle Targets for Joint Rule (DONE)
    - Test Multi-Group Splitting Rule (DONE)
    - Check Proposal to Compare (DONE)
        - Quality Metrics needs to be done
        - I think that almost everything in regards of the graph has been done except:
            - The untested and the unadded
            - The program that ties up all the components together
                - This includes a function that automates relationship change with targets
            - Graph Visualization
        - Generic Constraints
    - Read and Summarize new Kybartas Paper (DONE)
        - Uses the same story metrics as REGEN
08 Sep 2022
    - Map Representation in World State (DONE)
        - Function in World State, that given a LocationNode, returns all adjacent locations
    - StoryGenerationFunction's rule application will make a Location List this way:
        - Assume the location doesn't change
        - However, if there is an action node that calls for a location change, refer to the map and choose one random location to change to
        - After that, all the actions will be performed in that location unless there is another change
    - Location Adjecnecy Function in World State (DONE)
15 Sep 2022
    - Change the future World States according to Present (Done)
    - Memory issues from copying WorldStates, how much is too much
    - Record only changes to WorldState, keep latest version (DONE)
        - Pending: Rewind back in case of errors
        - Keep 2 world states: Initial Worldstate and Current Worldstate
            - In the case that there is a change to the worldstate, take the initial worldstate and apply all the changes in each step, then make that the new current worldstate
    - Function that takes Tag and Value as input, and then outputs the proper relationship change (where actor/target can be added later) (Done)
    - ApplyRule, but with past timesteps
        - 
    - Check if Character is in the same location
        - Take the init step, advance it until it hits the place we want to check, and then check relationship
25 Sep 2022
    - Undo state changes (DONE)
        - Run from the initial state, input number and run through?
        - Run from final state, input number and reverse?
    - Effect on next Timestep must be developed in order to define how the stories will change (Partially done, but still unsure)
        - Either this, or parameters are needed
            - Figure out what parameters are needed
            - Define how each actions/events will change states and tags
    - Rule Change in the story cannot force the State Changes yet
        - Oh, they are about to. We just need a little bit of setup.
    - Rewrite Rule that applies Story Node Changes then applies World State Changes (Planned, now we intend to interleave to make things clearer)
2 Oct 2022
    - Since RewriteRule uses Tags and Tags are supposed to depend on the current world state, we need to think of what we're supposed to do here
        - Only take into account the first step of the rewrite rule???
        - Remake it so that instead of attaching tag requirements to the change rules, attach requirements to the story nodes instead and check appropriateness of each node as the world state advances?
    - Interestingly, there is no reason that rewrite rule has to take StoryGraph as an input
        - We could use lists of story nodes as condition/replacement for stories
        - We could use lists of world states as condition/replacement for world states (and run a check)
            - Tags work with this method, however, World States requires concrete Characters and Objects, so we'll have to make customized rules for more specific nodes.
    - Still need to check if Character is in the Same Location
        - New EdgeReq type object?
        - ShareLocReq?
            - Contains a list of characters
            - Check the location of the first character, then check if the other characters are in the same location?
    - Need to remake WorldState to interleave with StoryNodes? (DONE)
    - We also need to have the RelChange pull the character from the WorldState instead of the initial character setting (Done)
        - This is required in order to make sure the characters are properly affected by changes when they take actions
        - Instead of calling objects directly, RelChange should contain the name and call the tag's name from the WorldState
        - We can do this, we have node_dict[(node name)]. We'll use it to call the node from the proper WorldState after all the required change are applied.
    - Paired items that are required in order to interact with other items
        - Need a specific key to interact with a door
        - Skeleton Keys exist, and might be able to open all doors
        - Like prof. said, this could work with pairing objects. Example:
            - Red Key {Type: Object, Unlocks: Red}
            - Red Door {Type: Object, State: Locked, UnlockWith: Red}
            - Skeleton Key {Type: Object, Unlocks: [Red, Green, Blue]} (We can exclude tags that a Skeleton Key don't unlock (For example: digital locks with no keyholes))
        - Tag Requirement for Items?
    - Did a bit of housekeeping and reduced some duplicate code into functions (Entire work will never be done but a lot of it was done. Thanks Ram!)
    - Break up with Magic Variables/Strings and use ENUM-like configurations instead. This includes: (DONE)
        - "add", "remove"
        - Markers for relative nodes
        - Joint Types
9 Oct 2022
    - How important is StoryNode.next_node, exactly...?
        - Since we could figure out next node/previous node information from the StoryGraph itself, it might not be that needed...
        - We'll keep it for now, but if it turns out there's no need to put it there we're removing it to streamline our work process.
13 Oct 2022
    - We need to discuss on how to handle adding step insertion
        # The Problem:
        # How to handle insertion?
        # In the examples, Char A and Char B have steps 0 to 4. A-B is inserted between 3 and 4 for Char A.
        # 1. Don't insert anything, non-inserted storyline stays where they are:
        # A: 0-1-2-3-A-B-4
        # B: 0-1-2-3-4
        # Pros: No need to alter storyline more than needed.
        # Cons: Might cause time to be a bit weird and joint nodes might end up in different steps.
        #
        # 2. Insert a few blank steps in the unaltered character's storyline.
        # A: 0-1-2-3-A-B-4
        # B: 0-1-2-3-X-X-4
        # Pros: Joint nodes will always be in the same timestep.
        # Cons: Might need to rework the "End Condition" to exclude wait nodes.
    - it's decided, we'll take case 1 (as long as it's in the same timestep, it should be fine, absolute step shouldn't matter)
    - We can use character to point back at Location? (DONE)
    - Same Location, use location from Story Node to check? We can do Follow Graph (DONE)
        - Same Location can now be checked! Hooray!
    - Moved Enums to Utility (DONE)
20 Oct 2022
    - Work on the ConditionTest objects, so that changes can be dictated using them (DONE)
    - Consider if other ConditionTest objects are needed
        - We will only go with the basic 4 tests for now and make more as needed.
03 Nov 2022
    - Created a new function called Fill Locations On Self, which allows Location Data to come from the WorldState instead of the add node input itself (DONE)
    - Finished the function called Check Continuation Validity that checks if a given continuation is valid. (Done, Partially Tested)
    - Make Inverese tests (DONE)
    - Revise the Apply Rule function so it only adds rather than remove then add
        - This also means we must also redo the apply replacement rule function?
10 Nov 2022 (Happy Birthday! You're 3 days late)
    - Redo the Replacement Rules to maybe include a slot for targets so that we can pull information from there into the add node function
        - Replacement rules no longer need dummy char, because we will now only use a list of nodes
        - target list will also be able to be included
        - Put all the targets in the rewrite rules, yeah!
    - Need to redo quite a few functions!
        - is_subgraph (DONE)
        - rewrite rule function, so instead of removing nodes it only insert new nodes
            - Reasons to keep old function: Replacement could work for "Non-Terminal Symbols"
                - For example, Bob goes Outside -> (Heroic Deed) -> Bob Gets Awarded
                - Heroic Deed is intended to be a non-terminal symbol to be replaced that will be replaced with a storyline that fits the criteria of a heroic deed.
            - Proposal: Figure out a way to let the system know when to do replacement and when to do only insertion (DONE)
                - Special property within RewriteRule? (We could go with this, it's just one boolean) (WE DID THIS ITS DONE)
                - If the beginning is the same, don't replace?
17 Nov 2022
    - Current method only allows story nodes with unique names.
    - We probably should rename story nodes to make them less confusing.
        - Might need to ensure Story Node VS Character Node VS Location Node VS Object Node don't sound too confusing on Paper
        - Maybe go back to using StoryPart?
    - New Rewrite Rule is now done and has to be Tested
    - Check if the Joint Rule still works with the new WS format
        - Whoops, when I checked on friday it didn't. Good thing I fixed it on Monday!
        - Still needs testing, though.
    - Hey, uh, so remember the split joint thing we implemented? If we want to keep it, we probably need to figure out a way to include that information in the Rewrite Rules?
        - How do we know how to split? We put in a rule, and we give the split list some sort of distribution?
        - Distribution could be based on randomization or character bias ranking?
        - Make a list of all possible permutations and randomly choose one from the valid list?
        - Probably should consult professor about this
        - Random first, then check if this combination is good
    - Plot out Rules, Init Test WS, Characters, Objects, and decide the kind of story we want to generate (important)
24 Nov 2022
    - Change the Tag check requirements (Done and Tested!)
        - If the value is blank, then it can be anything
        - We extended this and added the values to the edges too.
    - Splitting Joint should just randomly assign characters and then go with the first combination that works (Done, Tested)
    - Since we rewrote a bunch of new Edge functions, we should test the following: (COMPLETE)
        - StoryNode: Check if Item has Tag (TESTED)
        - WorldState: Disconnect (TESTED)
        - Edge: Edge Equality (both __eq__ and soft_equal) (TESTED)
        - ConditionTest: HasEdge must be tested (Double Has Edge gets a free pass because it's based off of HasEdge) (TESTED)
    - Plot the World State and Initial Graph State, based on ReGEN
08 Nov 2022
    - Well, we did it, we're going to need more Replacement Rules
        - Take from Quest Generator
        - Finish implanting parts from ReGEN that we haven't added from the other sheet yet
    - Try to plot some representations in our code
        - Since we foresee that we will need a way to input the data, we will need to start working on the thing that will let us read json files/strings and translate them to proper objects
        - We need to figure out which JSON things we need and don't need as well
            - JSON Story Objects
                - JSON Locations
                - JSON Characters
            - JSON Story Graphs
            - JSON Story Nodes
            - JSON Replacement Rules
            - JSON RelChanges
            - JSON Edges
            - JSON Condition Tests
            - JSON World States
        - If we're doing JSON things we need to figure out how we handle connecting to other things
            - For example, defining an Edge requires referencing nodes. We need to handle that
            - Use the character/object name as IDs?
            - Make a new ID property?
    - Go read Quest Generator again to see where the story parts came from
        - Possibly Witcher?
        - Fallout? (Main Quest)
        - Skyrim (Main Quest)
        - I checked out these games and all they gave me are highly branched out questlines that feel like they'd be out of my scope to replicate
        - Also, I'm pretty sure the story parts used here are completely original, there doesn't seem to be any rules here...
15 Nov 2022
    - Update the JSON things to accept lists
    - Determine all the JSON functions we need to write
    - Show the prof examples of nodes and objects from ReGEN in JSON Form